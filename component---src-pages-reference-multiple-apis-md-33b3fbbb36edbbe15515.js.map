{"version":3,"sources":["webpack://dev-site-documentation-template/./src/pages/reference/multiple-apis.md"],"names":["name","_frontmatter","InlineAlert","props","console","warn","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","mdxType","parentName","variant","slots","isMDXComponent"],"mappings":"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","file":"component---src-pages-reference-multiple-apis-md-33b3fbbb36edbbe15515.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/graphql-mesh-gateway/graphql-mesh-gateway/node_modules/@adobe/gatsby-theme-aio/src/components/MDXFilter/index.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst InlineAlert = makeShortcode(\"InlineAlert\");\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"multiple-apis-recipe\"\n    }}>{`Multiple APIs recipe`}</h1>\n    <p>{`This topic describes the GraphQL Mesh recipe for using multiple apis.`}</p>\n    <p>{`GraphQL Mesh is able to merge different data sources into a single unified GraphQL Schema, and GraphQL Mesh is not an alternative to Schema Stitching, Apollo Federation, Bare Schema Merging or another merging strategy. GraphQL Mesh can consume and merge your data sources in different approaches.`}</p>\n    <p>{`In addition to `}<inlineCode parentName=\"p\">{`@apollo/gateway`}</inlineCode>{`, GraphQL Mesh supports subscriptions out-of-box.`}</p>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"https://product.voxmedia.com/2020/11/2/21494865/to-federate-or-stitch-a-graphql-gateway-revisited\"\n      }}>{`Learn more the key differences between Schema Stitching and Apollo Federation`}</a></p>\n    <h2 {...{\n      \"id\": \"extending-graphql-schema-with-additionaltypedefs\"\n    }}>{`Extending GraphQL Schema with `}<inlineCode parentName=\"h2\">{`additionalTypeDefs`}</inlineCode></h2>\n    <p>{`You can add new types and/or fields to the current unified GraphQL Schema by using `}<inlineCode parentName=\"p\">{`additionalTypeDefs`}</inlineCode>{` configuration field;`}</p>\n    <p>{`Let's say we have the StackExchange API in our Mesh configuration;`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"StackExchange\",\n      \"handler\": {\n        \"openapi\": {\n          \"source\": \"https://raw.githubusercontent.com/grokify/api-specs/master/stackexchange/stackexchange-api-v2.2_openapi-v3.0.yaml\"\n        }\n      }\n    }\n  ],\n  \"additionalTypeDefs\": \"extend type Query {\\\\n  listQuestionsFromStackOverflow(first: Int!): [Question]\\\\n}\\\\n\"\n}\n`}</code></pre>\n    <p>{`And here we add a new field under `}<inlineCode parentName=\"p\">{`Query`}</inlineCode>{` root type named `}<inlineCode parentName=\"p\">{`viewsInPastMonth`}</inlineCode>{`. But we need a resolver for this new field.`}</p>\n    <h2 {...{\n      \"id\": \"declare-a-resolver-to-the-new-additionaltypedefs-by-using-additionalresolvers\"\n    }}>{`Declare a resolver to the new `}<inlineCode parentName=\"h2\">{`additionalTypeDefs`}</inlineCode>{` by using `}<inlineCode parentName=\"h2\">{`additionalResolvers`}</inlineCode></h2>\n    <p>{`We have `}<inlineCode parentName=\"p\">{`additionalResolvers`}</inlineCode>{` field to make our new field executable in the unified schema;`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"StackExchange\",\n      \"handler\": {\n        \"openapi\": {\n          \"source\": \"https://raw.githubusercontent.com/grokify/api-specs/master/stackexchange/stackexchange-api-v2.2_openapi-v3.0.yaml\"\n        }\n      }\n    }\n  ],\n  \"additionalTypeDefs\": \"extend type Query {\\\\n  listQuestionsFromStackOverflow(first: Int!): [Question]\\\\n}\\\\n\",\n  \"additionalResolvers\": [\n    {\n      \"targetTypeName\": \"Query\",\n      \"targetFieldName\": \"listQuestionsFromStackOverflow\",\n      \"sourceName\": \"StackExchange\",\n      \"sourceTypeName\": \"Query\",\n      \"sourceFieldName\": \"listQuestions\",\n      \"sourceArgs\": {\n        \"pagesize\": \"{args.first}\"\n      },\n      \"result\": \"items\"\n    }\n  ]\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"combining-schemas-using-declarative-api\"\n    }}>{`Combining Schemas using declarative API`}</h2>\n    <p>{`We learnt that we can combine multiple APIs in Mesh using `}<inlineCode parentName=\"p\">{`additionalTypeDefs`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`additionalResolvers`}</inlineCode>{`.`}</p>\n    <p>{`The following example has two different OpenAPI sources; we add two new fields to a type of `}<inlineCode parentName=\"p\">{`Cities`}</inlineCode>{`, and those fields have return types from `}<inlineCode parentName=\"p\">{`Weather`}</inlineCode>{` API.`}</p>\n    <p>{`But this time we don't use an extra resolvers file for `}<inlineCode parentName=\"p\">{`additionalResolvers`}</inlineCode>{` but only the configuration file.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"Cities\",\n      \"handler\": {\n        \"openapi\": {\n          \"source\": \"https://api.apis.guru/v2/specs/mashape.com/geodb/1.0.0/swagger.json\",\n          \"operationHeaders\": {\n            \"X-RapidAPI-Key\": \"f93d3b393dmsh13fea7cb6981b2ep1dba0ajsn654ffeb48c26\"\n          }\n        }\n      }\n    },\n    {\n      \"name\": \"Weather\",\n      \"handler\": {\n        \"openapi\": {\n          \"source\": \"https://api.apis.guru/v2/specs/weatherbit.io/2.0.0/swagger.json\"\n        }\n      }\n    }\n  ],\n  \"additionalTypeDefs\": \"extend type PopulatedPlaceSummary {\\\\n  dailyForecast: [Forecast]\\\\n  todayForecast: Forecast\\\\n}\\\\n\",\n  \"additionalResolvers\": [\n    {\n      \"targetTypeName\": \"PopulatedPlaceSummary\",\n      \"targetFieldName\": \"dailyForecast\",\n      \"requiredSelectionSet\": \"{\\\\n  latitude\\\\n  longitude\\\\n}\\\\n\",\n      \"sourceName\": \"Weather\",\n      \"sourceTypeName\": \"Query\",\n      \"sourceFieldName\": \"getForecastDailyLatLatLonLon\",\n      \"sourceArgs\": {\n        \"lat\": \"{root.latitude}\",\n        \"lon\": \"{root.longitude}\",\n        \"key\": \"{context.headers['x-weather-api-key']}\"\n      },\n      \"result\": \"data\"\n    },\n    {\n      \"type\": \"PopulatedPlaceSummary\",\n      \"field\": \"todayForecast\",\n      \"requiredSelectionSet\": \"{\\\\n  latitude\\\\n  longitude\\\\n}\\\\n\",\n      \"sourceName\": \"Weather\",\n      \"sourceTypeName\": \"Query\",\n      \"sourceFieldName\": \"getForecastDailyLatLatLonLon\",\n      \"sourceArgs\": {\n        \"lat\": \"{root.latitude}\",\n        \"lon\": \"{root.longitude}\",\n        \"key\": \"{context.headers['x-weather-api-key']}\"\n      },\n      \"result\": \"data[0]\"\n    }\n  ]\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"merging-types-from-different-sources-using-type-merging\"\n    }}>{`Merging types from different sources (using Type Merging)`}</h2>\n    <p>{`Let's say you have two different services; `}<inlineCode parentName=\"p\">{`Books`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`Authors`}</inlineCode>{`. And those two are exposing the following schemas at the end;`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`# Authors\ntype Query {\n  authors(ids: [ID!]): [Author!]!\n  author(id: ID!): Author!\n}\n\ntype Author {\n  id: ID!\n  name: String!\n}\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`# Books\ntype Query {\n  books(ids: [ID!]): [Book!]!\n  book(id: ID!): Book!\n  authorWithBooks(id: ID!): Author!\n  authorsWithBooks(ids: [ID!]): [Author!]!\n}\n\ntype Book {\n  id: ID!\n  title: String!\n  authorId: ID!\n}\n\ntype AuthorWithBooks {\n  id: ID!\n  books: [Book!]!\n}\n`}</code></pre>\n    <p>{`And you renamed `}<inlineCode parentName=\"p\">{`AuthorWithBooks`}</inlineCode>{` to `}<inlineCode parentName=\"p\">{`Author`}</inlineCode>{` using `}<a parentName=\"p\" {...{\n        \"href\": \"transforms/rename.md\"\n      }}><inlineCode parentName=\"a\">{`Rename`}</inlineCode></a>{` transform.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`[\n  {\n    \"sources\": [\n      {\n        \"name\": \"BookService\",\n        \"handler\": null,\n        \"transforms\": [\n          {\n            \"rename\": {\n              \"renames\": [\n                {\n                  \"from\": {\n                    \"type\": \"AuthorWithBooks\"\n                  },\n                  \"to\": {\n                    \"type\": \"Author\"\n                  }\n                },\n                {\n                  \"from\": {\n                    \"type\": \"Query\",\n                    \"field\": \"authorWithBooks\"\n                  },\n                  \"to\": {\n                    \"type\": \"Query\",\n                    \"field\": \"author\"\n                  }\n                }\n              ]\n            }\n          }\n        ]\n      }\n    ]\n  }\n]\n`}</code></pre>\n    <p>{` then you expect following query works fine;`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`{\n  author(id: 0) {\n    id # This field is common\n    name # This field is from \\`AuthorService\\`\n    books { # This field is from \\`BookService\\`\n      id\n      title\n    }\n  }\n}\n`}</code></pre>\n    <p>{`But it won't work because Mesh doesn't know which field belongs to where and how to combing those. For sure, you could add `}<inlineCode parentName=\"p\">{`additionalResolvers`}</inlineCode>{` then extract `}<inlineCode parentName=\"p\">{`books`}</inlineCode>{` from `}<inlineCode parentName=\"p\">{`AuthorWithBooks`}</inlineCode>{` then return it as `}<inlineCode parentName=\"p\">{`books`}</inlineCode>{` field of `}<inlineCode parentName=\"p\">{`Author`}</inlineCode>{` type but this sounds a little bit overhead. So let's try Type Merging here;`}</p>\n    <p>{`We have Type Merging transform to teach Mesh how to fetch entities from different sources;`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"AuthorService\",\n      \"handler\": null,\n      \"transforms\": [\n        {\n          \"typeMerging\": {\n            \"queryFields\": [\n              {\n                \"queryFieldName\": \"author\",\n                \"keyField\": \"id\"\n              }\n            ]\n          }\n        }\n      ]\n    },\n    {\n      \"name\": \"BookService\",\n      \"handler\": null,\n      \"transforms\": [\n        {\n          \"rename\": {\n            \"renames\": [\n              {\n                \"from\": {\n                  \"type\": \"AuthorWithBooks\"\n                },\n                \"to\": {\n                  \"type\": \"Author\"\n                }\n              },\n              {\n                \"from\": {\n                  \"type\": \"Query\",\n                  \"field\": \"authorWithBooks\"\n                },\n                \"to\": {\n                  \"type\": \"Query\",\n                  \"field\": \"author\"\n                }\n              },\n              {\n                \"from\": {\n                  \"type\": \"Query\",\n                  \"field\": \"authorsWithBooks\"\n                },\n                \"to\": {\n                  \"type\": \"Query\",\n                  \"field\": \"authors\"\n                }\n              }\n            ]\n          }\n        },\n        {\n          \"typeMerging\": {\n            \"queryFields\": [\n              {\n                \"queryFieldName\": \"book\",\n                \"keyField\": \"id\"\n              },\n              {\n                \"queryFieldName\": \"author\",\n                \"keyField\": \"id\"\n              }\n            ]\n          }\n        }\n      ]\n    }\n  ]\n}\n`}</code></pre>\n    <p>{`Then now our query will work as expected!`}</p>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"transforms/type-merging.md\"\n      }}>{`Check this out learn more about Type Merging transform`}</a>{`.`}</p>\n    <h2 {...{\n      \"id\": \"batching-requests-between-sources-to-prevent-n1-problem\"\n    }}>{`Batching requests between sources to prevent N+1 problem`}</h2>\n    <h3 {...{\n      \"id\": \"in-type-merging\"\n    }}>{`In type merging`}</h3>\n    <p>{`The example above works fine but there is an N+1 problem. It sends `}<inlineCode parentName=\"p\">{`n`}</inlineCode>{` requests for `}<inlineCode parentName=\"p\">{`n`}</inlineCode>{` entities. But we have `}<inlineCode parentName=\"p\">{`authors`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`books`}</inlineCode>{`. Type Merging is smart enough to handle batching if you point it to a field that returns a list of entities. Let's update our configuration for this;`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"AuthorService\",\n      \"handler\": null,\n      \"transforms\": [\n        {\n          \"typeMerging\": {\n            \"queryFields\": [\n              {\n                \"queryFieldName\": \"authors\",\n                \"keyField\": \"id\"\n              }\n            ]\n          }\n        }\n      ]\n    },\n    {\n      \"name\": \"BookService\",\n      \"handler\": null,\n      \"transforms\": [\n        {\n          \"rename\": {\n            \"renames\": [\n              {\n                \"from\": {\n                  \"type\": \"AuthorWithBooks\"\n                },\n                \"to\": {\n                  \"type\": \"Author\"\n                }\n              },\n              {\n                \"from\": {\n                  \"type\": \"Query\",\n                  \"field\": \"authorWithBooks\"\n                },\n                \"to\": {\n                  \"type\": \"Query\",\n                  \"field\": \"author\"\n                }\n              },\n              {\n                \"from\": {\n                  \"type\": \"Query\",\n                  \"field\": \"authorsWithBooks\"\n                },\n                \"to\": {\n                  \"type\": \"Query\",\n                  \"field\": \"authors\"\n                }\n              }\n            ]\n          }\n        },\n        {\n          \"typeMerging\": {\n            \"queryFields\": [\n              {\n                \"queryFieldName\": \"books\",\n                \"keyField\": \"id\"\n              },\n              {\n                \"queryFieldName\": \"authors\",\n                \"keyField\": \"id\"\n              }\n            ]\n          }\n        }\n      ]\n    }\n  ]\n}\n`}</code></pre>\n    <p>{`And now it batches the requests to the inner sources.`}</p>\n    <h3 {...{\n      \"id\": \"in-regular-additionalresolvers\"\n    }}>{`In regular `}<inlineCode parentName=\"h3\">{`additionalResolvers`}</inlineCode></h3>\n    <p>{`In the current example, we want to have a field called `}<inlineCode parentName=\"p\">{`author`}</inlineCode>{` under `}<inlineCode parentName=\"p\">{`Book`}</inlineCode>{` property then point it to `}<inlineCode parentName=\"p\">{`author`}</inlineCode>{`.`}</p>\n    <p>{`Normally we supposed to do the following definitions;`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"additionalTypeDefs\": \"extend type Book {\\\\n  author: Author\\\\n}\\\\n\",\n  \"additionalResolvers\": [\n    {\n      \"sourceName\": \"AuthorService\",\n      \"sourceTypeName\": \"Query\",\n      \"sourceFieldName\": \"author\",\n      \"sourceArgs\": {\n        \"id\": \"{root.authorId}\"\n      },\n      \"targetTypeName\": \"Book\",\n      \"targetFieldName\": \"author\",\n      \"requiredSelectionSet\": \"{authorId}\"\n    }\n  ]\n}\n`}</code></pre>\n    <p>{`But we want to solve N+1 problem;`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"additionalResolvers\": [\n    {\n      \"sourceName\": \"AuthorService\",\n      \"sourceTypeName\": \"Query\",\n      \"sourceFieldName\": \"authors\",\n      \"keyField\": \"authorId\",\n      \"keysArg\": \"ids\",\n      \"targetTypeName\": \"Book\",\n      \"targetFieldName\": \"author\"\n    }\n  ]\n}\n`}</code></pre>\n    <p>{`And that's it. Now GraphQL Mesh will batch the queries of `}<inlineCode parentName=\"p\">{`Book.author`}</inlineCode>{` by using `}<inlineCode parentName=\"p\">{`authorId`}</inlineCode>{` field into `}<inlineCode parentName=\"p\">{`Query.authors`}</inlineCode>{`.`}</p>\n    <h2 {...{\n      \"id\": \"consuming-apollo-federation-services-inside-graphql-mesh\"\n    }}>{`Consuming Apollo Federation Services inside GraphQL Mesh`}</h2>\n    <p>{`GraphQL Mesh uses `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/gmac/schema-stitching-handbook/tree/master/federation-services\"\n      }}>{`the approach of Schema Stitching`}</a>{` in order to consume the existing Apollo Federation services inside GraphQL Mesh. So you can combine Federation and Type Merging in GraphQL Mesh`}</p>\n    <p>{`You can follow Apollo Federation spec and integrate your existing Federated services into GraphQL Mesh.`}</p>\n    <p>{`GraphQL Mesh is smart enough to mix and match Federation and Stitching approaches including all other transforms (Type Merging, Rename, Filter etc.)`}</p>\n    <p>{`You can also transform your existing non-federated schemas into federated service.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"accounts\",\n      \"handler\": {\n        \"graphql\": {\n          \"endpoint\": \"http://localhost:4001/graphql\"\n        }\n      },\n      \"transforms\": [\n        {\n          \"federation\": {\n            \"types\": [\n              {\n                \"name\": \"Query\",\n                \"config\": {\n                  \"extend\": true\n                }\n              },\n              {\n                \"name\": \"User\",\n                \"config\": {\n                  \"keyFields\": [\n                    \"id\"\n                  ],\n                  \"resolveReference\": {\n                    \"queryFieldName\": \"user\"\n                  }\n                }\n              }\n            ]\n          }\n        }\n      ]\n    },\n    {\n      \"name\": \"reviews\",\n      \"handler\": {\n        \"graphql\": {\n          \"endpoint\": \"http://localhost:4002/graphql\"\n        }\n      }\n    },\n    {\n      \"name\": \"products\",\n      \"handler\": {\n        \"graphql\": {\n          \"endpoint\": \"http://localhost:4003/graphql\"\n        }\n      }\n    },\n    {\n      \"name\": \"inventory\",\n      \"handler\": {\n        \"graphql\": {\n          \"endpoint\": \"http://localhost:4004/graphql\"\n        }\n      }\n    }\n  ]\n}\n`}</code></pre>\n    <InlineAlert variant=\"info\" slots=\"text\" mdxType=\"InlineAlert\" />\n    <p>{` You can `}<a parentName=\"p\" {...{\n        \"href\": \"transforms/federation.md\"\n      }}>{`check out documentation of federation transformer`}</a>{` to learn more about adding federation metadata to a non-federated GraphQL Schema.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}