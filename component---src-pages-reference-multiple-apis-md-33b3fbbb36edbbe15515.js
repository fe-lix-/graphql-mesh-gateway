(self.webpackChunkdev_site_documentation_template=self.webpackChunkdev_site_documentation_template||[]).push([[806],{48822:function(e,n,a){"use strict";a.r(n),a.d(n,{_frontmatter:function(){return l},default:function(){return h}});var t,o=a(22122),r=a(19756),i=(a(15007),a(64983)),d=a(99536),s=["components"],l={},m=(t="InlineAlert",function(e){return console.warn("Component "+t+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.mdx)("div",e)}),p={_frontmatter:l},u=d.Z;function h(e){var n=e.components,a=(0,r.Z)(e,s);return(0,i.mdx)(u,(0,o.Z)({},p,a,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("h1",{id:"multiple-apis-recipe"},"Multiple APIs recipe"),(0,i.mdx)("p",null,"This topic describes the GraphQL Mesh recipe for using multiple apis."),(0,i.mdx)("p",null,"GraphQL Mesh is able to merge different data sources into a single unified GraphQL Schema, and GraphQL Mesh is not an alternative to Schema Stitching, Apollo Federation, Bare Schema Merging or another merging strategy. GraphQL Mesh can consume and merge your data sources in different approaches."),(0,i.mdx)("p",null,"In addition to ",(0,i.mdx)("inlineCode",{parentName:"p"},"@apollo/gateway"),", GraphQL Mesh supports subscriptions out-of-box."),(0,i.mdx)("p",null,(0,i.mdx)("a",{parentName:"p",href:"https://product.voxmedia.com/2020/11/2/21494865/to-federate-or-stitch-a-graphql-gateway-revisited"},"Learn more the key differences between Schema Stitching and Apollo Federation")),(0,i.mdx)("h2",{id:"extending-graphql-schema-with-additionaltypedefs"},"Extending GraphQL Schema with ",(0,i.mdx)("inlineCode",{parentName:"h2"},"additionalTypeDefs")),(0,i.mdx)("p",null,"You can add new types and/or fields to the current unified GraphQL Schema by using ",(0,i.mdx)("inlineCode",{parentName:"p"},"additionalTypeDefs")," configuration field;"),(0,i.mdx)("p",null,"Let's say we have the StackExchange API in our Mesh configuration;"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [\n    {\n      "name": "StackExchange",\n      "handler": {\n        "openapi": {\n          "source": "https://raw.githubusercontent.com/grokify/api-specs/master/stackexchange/stackexchange-api-v2.2_openapi-v3.0.yaml"\n        }\n      }\n    }\n  ],\n  "additionalTypeDefs": "extend type Query {\\n  listQuestionsFromStackOverflow(first: Int!): [Question]\\n}\\n"\n}\n')),(0,i.mdx)("p",null,"And here we add a new field under ",(0,i.mdx)("inlineCode",{parentName:"p"},"Query")," root type named ",(0,i.mdx)("inlineCode",{parentName:"p"},"viewsInPastMonth"),". But we need a resolver for this new field."),(0,i.mdx)("h2",{id:"declare-a-resolver-to-the-new-additionaltypedefs-by-using-additionalresolvers"},"Declare a resolver to the new ",(0,i.mdx)("inlineCode",{parentName:"h2"},"additionalTypeDefs")," by using ",(0,i.mdx)("inlineCode",{parentName:"h2"},"additionalResolvers")),(0,i.mdx)("p",null,"We have ",(0,i.mdx)("inlineCode",{parentName:"p"},"additionalResolvers")," field to make our new field executable in the unified schema;"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [\n    {\n      "name": "StackExchange",\n      "handler": {\n        "openapi": {\n          "source": "https://raw.githubusercontent.com/grokify/api-specs/master/stackexchange/stackexchange-api-v2.2_openapi-v3.0.yaml"\n        }\n      }\n    }\n  ],\n  "additionalTypeDefs": "extend type Query {\\n  listQuestionsFromStackOverflow(first: Int!): [Question]\\n}\\n",\n  "additionalResolvers": [\n    {\n      "targetTypeName": "Query",\n      "targetFieldName": "listQuestionsFromStackOverflow",\n      "sourceName": "StackExchange",\n      "sourceTypeName": "Query",\n      "sourceFieldName": "listQuestions",\n      "sourceArgs": {\n        "pagesize": "{args.first}"\n      },\n      "result": "items"\n    }\n  ]\n}\n')),(0,i.mdx)("h2",{id:"combining-schemas-using-declarative-api"},"Combining Schemas using declarative API"),(0,i.mdx)("p",null,"We learnt that we can combine multiple APIs in Mesh using ",(0,i.mdx)("inlineCode",{parentName:"p"},"additionalTypeDefs")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"additionalResolvers"),"."),(0,i.mdx)("p",null,"The following example has two different OpenAPI sources; we add two new fields to a type of ",(0,i.mdx)("inlineCode",{parentName:"p"},"Cities"),", and those fields have return types from ",(0,i.mdx)("inlineCode",{parentName:"p"},"Weather")," API."),(0,i.mdx)("p",null,"But this time we don't use an extra resolvers file for ",(0,i.mdx)("inlineCode",{parentName:"p"},"additionalResolvers")," but only the configuration file."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [\n    {\n      "name": "Cities",\n      "handler": {\n        "openapi": {\n          "source": "https://api.apis.guru/v2/specs/mashape.com/geodb/1.0.0/swagger.json",\n          "operationHeaders": {\n            "X-RapidAPI-Key": "f93d3b393dmsh13fea7cb6981b2ep1dba0ajsn654ffeb48c26"\n          }\n        }\n      }\n    },\n    {\n      "name": "Weather",\n      "handler": {\n        "openapi": {\n          "source": "https://api.apis.guru/v2/specs/weatherbit.io/2.0.0/swagger.json"\n        }\n      }\n    }\n  ],\n  "additionalTypeDefs": "extend type PopulatedPlaceSummary {\\n  dailyForecast: [Forecast]\\n  todayForecast: Forecast\\n}\\n",\n  "additionalResolvers": [\n    {\n      "targetTypeName": "PopulatedPlaceSummary",\n      "targetFieldName": "dailyForecast",\n      "requiredSelectionSet": "{\\n  latitude\\n  longitude\\n}\\n",\n      "sourceName": "Weather",\n      "sourceTypeName": "Query",\n      "sourceFieldName": "getForecastDailyLatLatLonLon",\n      "sourceArgs": {\n        "lat": "{root.latitude}",\n        "lon": "{root.longitude}",\n        "key": "{context.headers[\'x-weather-api-key\']}"\n      },\n      "result": "data"\n    },\n    {\n      "type": "PopulatedPlaceSummary",\n      "field": "todayForecast",\n      "requiredSelectionSet": "{\\n  latitude\\n  longitude\\n}\\n",\n      "sourceName": "Weather",\n      "sourceTypeName": "Query",\n      "sourceFieldName": "getForecastDailyLatLatLonLon",\n      "sourceArgs": {\n        "lat": "{root.latitude}",\n        "lon": "{root.longitude}",\n        "key": "{context.headers[\'x-weather-api-key\']}"\n      },\n      "result": "data[0]"\n    }\n  ]\n}\n')),(0,i.mdx)("h2",{id:"merging-types-from-different-sources-using-type-merging"},"Merging types from different sources (using Type Merging)"),(0,i.mdx)("p",null,"Let's say you have two different services; ",(0,i.mdx)("inlineCode",{parentName:"p"},"Books")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"Authors"),". And those two are exposing the following schemas at the end;"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-graphql"},"# Authors\ntype Query {\n  authors(ids: [ID!]): [Author!]!\n  author(id: ID!): Author!\n}\n\ntype Author {\n  id: ID!\n  name: String!\n}\n")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-graphql"},"# Books\ntype Query {\n  books(ids: [ID!]): [Book!]!\n  book(id: ID!): Book!\n  authorWithBooks(id: ID!): Author!\n  authorsWithBooks(ids: [ID!]): [Author!]!\n}\n\ntype Book {\n  id: ID!\n  title: String!\n  authorId: ID!\n}\n\ntype AuthorWithBooks {\n  id: ID!\n  books: [Book!]!\n}\n")),(0,i.mdx)("p",null,"And you renamed ",(0,i.mdx)("inlineCode",{parentName:"p"},"AuthorWithBooks")," to ",(0,i.mdx)("inlineCode",{parentName:"p"},"Author")," using ",(0,i.mdx)("a",{parentName:"p",href:"transforms/rename.md"},(0,i.mdx)("inlineCode",{parentName:"a"},"Rename"))," transform."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "sources": [\n      {\n        "name": "BookService",\n        "handler": null,\n        "transforms": [\n          {\n            "rename": {\n              "renames": [\n                {\n                  "from": {\n                    "type": "AuthorWithBooks"\n                  },\n                  "to": {\n                    "type": "Author"\n                  }\n                },\n                {\n                  "from": {\n                    "type": "Query",\n                    "field": "authorWithBooks"\n                  },\n                  "to": {\n                    "type": "Query",\n                    "field": "author"\n                  }\n                }\n              ]\n            }\n          }\n        ]\n      }\n    ]\n  }\n]\n')),(0,i.mdx)("p",null," then you expect following query works fine;"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-graphql"},"{\n  author(id: 0) {\n    id # This field is common\n    name # This field is from `AuthorService`\n    books { # This field is from `BookService`\n      id\n      title\n    }\n  }\n}\n")),(0,i.mdx)("p",null,"But it won't work because Mesh doesn't know which field belongs to where and how to combing those. For sure, you could add ",(0,i.mdx)("inlineCode",{parentName:"p"},"additionalResolvers")," then extract ",(0,i.mdx)("inlineCode",{parentName:"p"},"books")," from ",(0,i.mdx)("inlineCode",{parentName:"p"},"AuthorWithBooks")," then return it as ",(0,i.mdx)("inlineCode",{parentName:"p"},"books")," field of ",(0,i.mdx)("inlineCode",{parentName:"p"},"Author")," type but this sounds a little bit overhead. So let's try Type Merging here;"),(0,i.mdx)("p",null,"We have Type Merging transform to teach Mesh how to fetch entities from different sources;"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [\n    {\n      "name": "AuthorService",\n      "handler": null,\n      "transforms": [\n        {\n          "typeMerging": {\n            "queryFields": [\n              {\n                "queryFieldName": "author",\n                "keyField": "id"\n              }\n            ]\n          }\n        }\n      ]\n    },\n    {\n      "name": "BookService",\n      "handler": null,\n      "transforms": [\n        {\n          "rename": {\n            "renames": [\n              {\n                "from": {\n                  "type": "AuthorWithBooks"\n                },\n                "to": {\n                  "type": "Author"\n                }\n              },\n              {\n                "from": {\n                  "type": "Query",\n                  "field": "authorWithBooks"\n                },\n                "to": {\n                  "type": "Query",\n                  "field": "author"\n                }\n              },\n              {\n                "from": {\n                  "type": "Query",\n                  "field": "authorsWithBooks"\n                },\n                "to": {\n                  "type": "Query",\n                  "field": "authors"\n                }\n              }\n            ]\n          }\n        },\n        {\n          "typeMerging": {\n            "queryFields": [\n              {\n                "queryFieldName": "book",\n                "keyField": "id"\n              },\n              {\n                "queryFieldName": "author",\n                "keyField": "id"\n              }\n            ]\n          }\n        }\n      ]\n    }\n  ]\n}\n')),(0,i.mdx)("p",null,"Then now our query will work as expected!"),(0,i.mdx)("p",null,(0,i.mdx)("a",{parentName:"p",href:"transforms/type-merging.md"},"Check this out learn more about Type Merging transform"),"."),(0,i.mdx)("h2",{id:"batching-requests-between-sources-to-prevent-n1-problem"},"Batching requests between sources to prevent N+1 problem"),(0,i.mdx)("h3",{id:"in-type-merging"},"In type merging"),(0,i.mdx)("p",null,"The example above works fine but there is an N+1 problem. It sends ",(0,i.mdx)("inlineCode",{parentName:"p"},"n")," requests for ",(0,i.mdx)("inlineCode",{parentName:"p"},"n")," entities. But we have ",(0,i.mdx)("inlineCode",{parentName:"p"},"authors")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"books"),". Type Merging is smart enough to handle batching if you point it to a field that returns a list of entities. Let's update our configuration for this;"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [\n    {\n      "name": "AuthorService",\n      "handler": null,\n      "transforms": [\n        {\n          "typeMerging": {\n            "queryFields": [\n              {\n                "queryFieldName": "authors",\n                "keyField": "id"\n              }\n            ]\n          }\n        }\n      ]\n    },\n    {\n      "name": "BookService",\n      "handler": null,\n      "transforms": [\n        {\n          "rename": {\n            "renames": [\n              {\n                "from": {\n                  "type": "AuthorWithBooks"\n                },\n                "to": {\n                  "type": "Author"\n                }\n              },\n              {\n                "from": {\n                  "type": "Query",\n                  "field": "authorWithBooks"\n                },\n                "to": {\n                  "type": "Query",\n                  "field": "author"\n                }\n              },\n              {\n                "from": {\n                  "type": "Query",\n                  "field": "authorsWithBooks"\n                },\n                "to": {\n                  "type": "Query",\n                  "field": "authors"\n                }\n              }\n            ]\n          }\n        },\n        {\n          "typeMerging": {\n            "queryFields": [\n              {\n                "queryFieldName": "books",\n                "keyField": "id"\n              },\n              {\n                "queryFieldName": "authors",\n                "keyField": "id"\n              }\n            ]\n          }\n        }\n      ]\n    }\n  ]\n}\n')),(0,i.mdx)("p",null,"And now it batches the requests to the inner sources."),(0,i.mdx)("h3",{id:"in-regular-additionalresolvers"},"In regular ",(0,i.mdx)("inlineCode",{parentName:"h3"},"additionalResolvers")),(0,i.mdx)("p",null,"In the current example, we want to have a field called ",(0,i.mdx)("inlineCode",{parentName:"p"},"author")," under ",(0,i.mdx)("inlineCode",{parentName:"p"},"Book")," property then point it to ",(0,i.mdx)("inlineCode",{parentName:"p"},"author"),"."),(0,i.mdx)("p",null,"Normally we supposed to do the following definitions;"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "additionalTypeDefs": "extend type Book {\\n  author: Author\\n}\\n",\n  "additionalResolvers": [\n    {\n      "sourceName": "AuthorService",\n      "sourceTypeName": "Query",\n      "sourceFieldName": "author",\n      "sourceArgs": {\n        "id": "{root.authorId}"\n      },\n      "targetTypeName": "Book",\n      "targetFieldName": "author",\n      "requiredSelectionSet": "{authorId}"\n    }\n  ]\n}\n')),(0,i.mdx)("p",null,"But we want to solve N+1 problem;"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "additionalResolvers": [\n    {\n      "sourceName": "AuthorService",\n      "sourceTypeName": "Query",\n      "sourceFieldName": "authors",\n      "keyField": "authorId",\n      "keysArg": "ids",\n      "targetTypeName": "Book",\n      "targetFieldName": "author"\n    }\n  ]\n}\n')),(0,i.mdx)("p",null,"And that's it. Now GraphQL Mesh will batch the queries of ",(0,i.mdx)("inlineCode",{parentName:"p"},"Book.author")," by using ",(0,i.mdx)("inlineCode",{parentName:"p"},"authorId")," field into ",(0,i.mdx)("inlineCode",{parentName:"p"},"Query.authors"),"."),(0,i.mdx)("h2",{id:"consuming-apollo-federation-services-inside-graphql-mesh"},"Consuming Apollo Federation Services inside GraphQL Mesh"),(0,i.mdx)("p",null,"GraphQL Mesh uses ",(0,i.mdx)("a",{parentName:"p",href:"https://github.com/gmac/schema-stitching-handbook/tree/master/federation-services"},"the approach of Schema Stitching")," in order to consume the existing Apollo Federation services inside GraphQL Mesh. So you can combine Federation and Type Merging in GraphQL Mesh"),(0,i.mdx)("p",null,"You can follow Apollo Federation spec and integrate your existing Federated services into GraphQL Mesh."),(0,i.mdx)("p",null,"GraphQL Mesh is smart enough to mix and match Federation and Stitching approaches including all other transforms (Type Merging, Rename, Filter etc.)"),(0,i.mdx)("p",null,"You can also transform your existing non-federated schemas into federated service."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [\n    {\n      "name": "accounts",\n      "handler": {\n        "graphql": {\n          "endpoint": "http://localhost:4001/graphql"\n        }\n      },\n      "transforms": [\n        {\n          "federation": {\n            "types": [\n              {\n                "name": "Query",\n                "config": {\n                  "extend": true\n                }\n              },\n              {\n                "name": "User",\n                "config": {\n                  "keyFields": [\n                    "id"\n                  ],\n                  "resolveReference": {\n                    "queryFieldName": "user"\n                  }\n                }\n              }\n            ]\n          }\n        }\n      ]\n    },\n    {\n      "name": "reviews",\n      "handler": {\n        "graphql": {\n          "endpoint": "http://localhost:4002/graphql"\n        }\n      }\n    },\n    {\n      "name": "products",\n      "handler": {\n        "graphql": {\n          "endpoint": "http://localhost:4003/graphql"\n        }\n      }\n    },\n    {\n      "name": "inventory",\n      "handler": {\n        "graphql": {\n          "endpoint": "http://localhost:4004/graphql"\n        }\n      }\n    }\n  ]\n}\n')),(0,i.mdx)(m,{variant:"info",slots:"text",mdxType:"InlineAlert"}),(0,i.mdx)("p",null," You can ",(0,i.mdx)("a",{parentName:"p",href:"transforms/federation.md"},"check out documentation of federation transformer")," to learn more about adding federation metadata to a non-federated GraphQL Schema."))}h.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-reference-multiple-apis-md-33b3fbbb36edbbe15515.js.map